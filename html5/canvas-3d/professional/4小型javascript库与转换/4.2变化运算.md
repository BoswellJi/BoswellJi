## 变换

* webgl中执行，旋转，平移，缩放等操作实际上不需要手动执行矩阵相乘；（可以使用库 glMatrix；
* webgl以及一般的3D图形中，一般都是在用户坐标系中 `建立模型` ( `物体的3D模型` )，然后经过一系列不同变换，将他们正确的放到一个世界坐标系中（ `正确的位置和方向` ）；
* webgl中最麻烦的不是矩阵相乘，而是 `为了定位场景中的对象和照相机的位置，需要执行一系列的不同变化` ；

## webgl中经常提到的变换类型：

* 模型变换
* 视图变换
* 模型视图变换
* 投影变换
* 以上是根据 `顶点着色器` 中 `矩阵` 相乘运算实现；

* 透视除换
* 视口变换
* 以上是根据 `webgl流水线` 的 `图元装配` 阶段来处理; 

## 模型变换

* `顶点初始坐标` 称为 `对象坐标` ；
* 模型变换用来确当模型在世界坐标系中的位置和方向；
* 3D场景中的每个对象都有自己的模型变换；
  + 模型变换通常有：
    - 平移
    - 旋转
    - 缩放
* 只需要一个4*4矩阵就可以
* 为了将对象的顶点，从对象坐标系，换到世界坐标系，只需要将顶点坐标乘上这个4*4矩阵
* `mat4.translate()`
* `mat4.rotate()`
* `mat4.scale()`

## 视图变换

* 在3D场景中，webgl只对照相机（观察者）能够看到的对象进行绘制；
* 视图变换，用来确定对象在虚拟照相机中的位置和方向； `虚拟：webgl并没有显式方法用来移动场景中的照相机`
* `照相机` 总是位于原点位置，实线朝z轴负方向；
* 作用实际上是设置一个矩阵，它对场景中顶点的变换效果正好与变换照相机的效果相同
* 顶点经过视图变换后，它就处在眼睛坐标系中，因此就称它们为眼睛坐标
* `mat4.lookAt()` : 参数：照相机的位置，视线方向，上方向

## 模型视图变换

* 场景中照相机和对象之间的关系；
* 假设一个对象，和一个照相机都位于原点位置，照相机的视线沿着z轴负方向，怎样看到对象：
  + 将相机向后移动
  + 将对象向前移动到场景中，这里将兑现沿z轴负方向移动
* 使用一个矩阵乘上这个对象的顶点；
* 模型变换和视图变化和成了一个模型视图矩阵
* 当顶点直接从对象坐标系转换为眼睛坐标系
* 沿着某一个方向移动虚拟的照相机： 本质上相当于沿着相反方向移动全部顶点

## 投影变换

* 投影变换应用在模型视图变换之后，利用它确定如何在3D场景投影到屏幕上；
* 决定了视域体的外观
* 3D图形中的类比： 变换作用与用照相机拍摄部分对象的过程类比
  + 模型变换相当于场景中定位对象
  + 镜头决定了视野, 决定对象的效果；

### 投影变换类型

* 正交投影
  + 也叫平行投影
  + 平行线经过投影后仍然平行；
  + 不会因为对象距离观察者远，近影响对象的大小
  + `gl.ortho()` : 获取一个投影矩阵
* 透视投影
  + 距离观察者较远的对象看起来比较小
  + 视域体是一个锥台
  + `gl.perspective()` : 获取一个投影矩阵

## 透视除法

* 顶点着色器将坐标写入gl_Position变量时，在裁剪坐标系中进行该操作，用 `齐次坐标系，（x,y,z,w）` 表示
* 图元装配期间，顶点要经过 `透视除法` : 将所有坐标除以 `w` , 是为了得到 `归一化` 的设备坐标系；
* 裁剪坐标（x, y, z, w）与归一化设备坐标（x/w, y/w, z/w）

## 视口变换

* 图元装配操作的一部分，但是用户可以调用下面方法影响视口变换
  + `gl.viewPort(x,y,w,h)`
    - x，y: 视口左下角坐标
    - w, h: 宽，高
    - 综合以上两者定义一个视口
  + `gl.depthRange(n,f)`
    - 用户希望达到的景深范围
    - n: near近平面
    - f: far远平面
    - n不允许大于f,且值得范围都在【0-1】
