## 补丁

* 渲染器的第二个工作阶段；
* 对比新vnode与旧vnode,做出最小的修改；

## 组件的重新渲染的原因

* 重渲染是由组件的更新引起的；

## 新老vnode对比的条件：

* 凡是节点类型不同的vnode都会采用直接replace；
* vnode类型相同后进行其他的比较；

## vnode类型相同下的对比方法：

* 不同tag渲染的内容不同，直接替换；如果tag相同，vnode之间的差异就在于VNodeData和children;

## 有状态组件的更新

* 触发组件更新的情况；
* 组件更新的方式；

## 主动更新：组件自身状态发生变化引起的组件渲染；

* 组件状态变化需要重新执行渲染函数得到新的vnode,进而进行diff计算；
* 组件挂载的核心步骤：创建组件实例-调用render拿vnode-将vnode挂载到容器元素；

## 被动更新：由外部状态发生变换引起的组件渲染；