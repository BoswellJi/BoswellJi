## 图形硬件(gpu)

* webgl是一个低级api；建立在opengl es 2.0 之上； 因此它与实际的图形硬件密切相关；
* `应用程序` 运行在 `cpu` 上，并且使用 `主存RAM` ; 
* 为了显示3D图形， `应用程序` 需要不断 `调用底层驱动程序` ， `驱动程序` 通过 `总线` 把 `图形数据` 发送到 `图形处理单元gpu` ；
* 结构：
1. GPU流水线
  + 纹理存储器
2. 帧缓存
  + Z-Buffer
  + 颜色缓存
  + 模板缓存
3. 视频生成器

## GPU

* 专门设计的图形绘制设备，绘制输出在屏幕上的图像，GPu是高度并行化的，速度很快
* GPU: `采用流水线结构` , 数据从流水线的 `一个阶段` 传送到 `下一个阶段` ; 
* webgl: `图形流水线` 也是由多个阶段组成；他们与 `GPU物理流水线` 的各个阶段相对应；

## 帧缓存

* `图形数据` 通过整个 `GPU流水线` 传从后，最后写到 `帧缓存` 中（framebuffer）
* 是一个 `一个存储器` ; 
* 保存了最终显示在屏幕上图像的全部信息; 
* 用作 `帧缓存` 的 `物理内存` 有几种不同的 `位置` ; 
* 颜色缓存 
  + 颜色缓存
    - 通常保存了在某个时刻3d场景中，对观察者可见对象的颜色
    - 3D场景中，一个对象可能被其他对象遮挡，整个场景绘制完成时，颜色缓存中不会有`属于被隐藏对`象的`像素信息`；
    - 矩形阵列的存储器，以RGB或RGBA格式保存屏幕上每个像素的颜色； 16位 24位 32位
* Z-缓存 
  + Z-缓存： 3D场景中，一个对象可能会被其他对象遮挡，整个场景绘制完成时，颜色缓存中不会有被隐藏对象的像素信息，这通常是由Z-缓存来实现的（也叫深度缓存
* 模板缓存
  + 最新的图形硬件还包含模板缓存，可以用来控制在颜色缓存的某个位置写入操作；（处理阴影

## 纹理存储器

* 3D图形中，一个重要操作是把纹理应用于对象的表面，这些图像就是纹理，需要缓存保存它们；
* 这样gpu可以快速有效的访问它们；
* gpu有一个物理的 `纹理存储器` 用来 `存储纹理图像` ; 

## 视频控制器 

* 也叫视频生成器
* 以一定的频率逐行扫描颜色缓存，更新屏幕上的显示内容
* 对于lcd显示器，整个屏幕 `每秒60次更新` ，也就是 `刷新率` 为 `60Hz`
