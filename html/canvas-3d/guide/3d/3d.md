




## 视点，观察目标点，上方向

* 确定观察者的状态，需要的信息： 
  + 视点：观察者的 `位置`  `(eyeX,eyeY,eyeZ)`
  + 观察目标点：被观察目标所在的点，它可以用来确定 `视线`  `(atX,atY,atZ)`
  + 我们要把观察到的景象绘制到屏幕上，还好知道 `上方向`  `(upX,upY,upZ)` ；
* 使用上面三个矢量创建 `视图矩阵(表示观察者的状态，也就是上面三个矢量)` ，将矩阵传给 `顶点着色器` ; 

### 定义视图矩阵

* `setLookAt(eyeX,eyeY,eyeZ,atX,atY,atZ,upX,upY,upZ)创建视图矩阵`
* `根据自定义的观察者状态` ，绘制观察者看到的景象 与 `使用默认的观察状态` ，但是 `对三维对象进行平移，旋转，等变换` ，再绘制观察者看到的景象 两种行为 `等价` ; 

### webgl中观察者默认状态

* 视点位于 `(0,0,0)` , 系统原点；
* 视线为z轴负方向，观察点为 `（0,0,-1）` , 上方向为y轴正方向 `(0,1,0)` ; 

### 指定视点观察旋转后的三角形

* `旋转图形` ，就需要 `旋转矩阵` 乘以 `旋转前的顶点坐标` ；
  + 式子1： `<旋转后顶点坐标> = <旋转矩阵> * <原始顶点坐标>` ；
* `视图矩阵` 乘以 `旋转后的顶点坐标` ，就可以获取， `从视点看上去` 的 `旋转后的顶点坐标` ；
  + 式子2： `<从视点看上去的 旋转后顶点坐标> = <视图矩阵> * <旋转后的顶点坐标>` ；
* `视点移动` 与 `被观察对象` （真个三维世界）移动的 `方向正好相反` ；
* 式子1 + 式子2：<从视点看上去的 旋转后顶点坐标> = <视图矩阵> * <旋转矩阵> `(模型矩阵)` * <原始顶点坐标>; 
* < `视图矩阵` > * < `模型矩阵` > = <模型视图矩阵>

## 可视范围（正射类型

* 除了 `水平` 和 `垂直` 范围内的限制，webgl还限制了 `观察者` 的 `可视深度` ，即（ `能够看多远` ; 
* `水平视角` ， `垂直视角` ， `可视深度` 定义了**可视空间**；

## 可视空间

* 可视空间的近裁剪面的宽高比canvas不一致，显示出物体就会被压缩变形；

### 可视空间类型

* 长方体可视空间，盒状空间，由 `正射投影` 产生；
  + 在建筑平面图等技术绘图的相关场合使用；
  + 可以方便的比较场景中的物体（比如两个原子的模型）的大小，这是因为物体看上去的大小与其所在位置没有关系；

* 四棱锥/金字塔可视空间，由 `透视投影` 产生；

### 正射投影

* 盒状可视空间的工作原理；
* 可视空间由前后两个矩形表面确定，分别称为 `近裁剪面` 和 `远裁剪面` ; 

### 定义盒状可视空间

* `setOrtho(left, right, bottom, top, near, far )` 设置投影矩阵，称为正射投影矩阵，改变正射投影可视空间，来让物体展示完整，不会被遮挡；
* 修改 `可视空间的正射投影矩阵` 来确保三角形不被裁剪；

### 透视投影

* 三维场景看上去更是有深度感，更加自然，因为我们平时观察真实世界用的也是透视投影；

### 定义透视投影可视空间 

* `setPerspective(fov,aspect(近裁剪面的：宽高比),near,far)设置` 透视投影矩阵，改变透视投影可视空间，来让物体展示完整，不会被遮挡 ；

### 投影矩阵的作用

* 三角形看上去变小了；（ `根据三角形与视点的距离，按比例对三角形进行了缩小变换` ）
* 三角形被不同程度的平移来贴近中心线（即视线；（ `对三角形进行平移变换，使其贴近视线` ）

### 可视空间规范：

* `透视投影可视空间` 来说， `就是近，远裁剪面，垂直视角，宽高比` , 用一系列基本变换 `缩放，平移` 定义；
* `透视投影矩阵` 实际上将 `金字塔` 的 `可视空间变` 换为 `盒状的可视空间` ，这个 `盒状可视空间` 叫 `规范立方体` ；

### 矩阵类型

* 投影矩阵
* 视图矩阵（）
* 模型矩阵（平移，旋转，缩放）
* 有了以上 `矩阵` ，我们就能处理 `顶点` 需要经过的所有的 `几何变换` （平移，缩放，旋转），最终达到 `具有深度感` 的视觉效果

### 根据以上矩阵推断出：

* <投影矩阵> * <视图矩阵> * <模型矩阵> * <顶点矩阵> = <最终顶点坐标>

## 观察者状态设置，可视空间设置，带来的问题

### 正确处理对象的前后关系

* 问题: 
  + webgl为了加速绘图操作，是按照顶点在缓冲区的顺序来处理它们的；

* 原因：
  + 先定义远处物体，后定义近处物体，从而产生正确的效果，顺序相反的话，会远处的遮盖近处的；（因为顺序） 

* 解决方法：
  1. 隐藏面消除功能；（消除那些被遮挡的表面（隐藏面），这样绘制场景不必顾及各物体在缓冲区中的顺序， `那些远处的物体会自动被近处的物体遮挡住，不会被绘制出来` ，
  2. gl.enable(gl.DEPTH_TEST);
  3. gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT); 同时消除两个缓冲区
    - gl.DEPTH_BUFFER_BIT: 深度缓冲区，其作用就是帮助webgl进行隐藏面消除；
    - 由于深度方向通常是z轴方向，所以，也称为z缓冲区；

### 深度冲突：

* 问题：
  + 几何图形或者物体的两个表面极为接近时，使得表面看上去斑斑驳驳的现象；

* 原因：
  + 两个表面太过接近，深度缓冲区有限的精度已经不能区分哪个在前，在后了；

* 解决方法：
  1. 多边形偏移
  2. gl.enable(gl.POLYGON_OFFSET_FILL);
  3. gl.polygonOffset(1,1);

### 立方体

* 立方体的坐标系，以物体中心为原点；
* 立方体实际只有8个顶点；
* gl.drawElements(): 
  + 避免重复定义顶点；
  + 保持顶点数量最小；

* 立方体被拆成6个面：
  + 面：前 `与三角形列表中的两个三角形相关`
  + 三角形：（0，1，2）（0，2，3）
  + 顶点：（1，1，1）（-1，1，1）（-1，-1，1）  
  + 颜色 （1，1，1）（1，0，1）（1，0，0）

* gl.ELEMENT_ARRAY_BUFFER
  + 告诉webgl，该缓存的内容是顶点的索引数据；

* gl.ARRAY_BUFFER
  + 顶点坐标和颜色值

### 给立方体每个表面指定颜色
- 需要将颜色定义为逐顶点的信息；
