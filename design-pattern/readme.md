# 设计模式包含的内容：

## 面向对象

#### 基本概念

* 抽象
* 封装
* 继承
  + 缺点：
    - 是在编译时静态决定的，所有子类都有继承到相同的行为；

* 多态
* 接口
  + 要点：
    - 实现一个接口，泛指实现一个超类型，可以是接口，也可以是类；

#### 面向对象设计的基本原则

* 注意类之间的关系；IS-A(是一个) HAS-A(有一个/实现)

2\. 找出应用中可能需要变化之处，把他们独立出来，不要和不需要变化的代码混在一起；

3\. 针对接口编程，而不是针对实现编程；

4\. 多用组合，少用继承；

5\. 为了交互对象之间的松耦合设计而努力；（将对象之间的依赖降到最低）；

6\. 类应该对扩展开放，对修改关闭；

7\. 要依赖抽象，不要依赖具体类；（依赖倒置原则）

8\. 只和朋友交谈；

9\. 别找我，我会找你；

10. 类应该只有一个改变的理由；

## 设计模式
* 定义： `模式是在某种情境下，针对某问题的某种解决方案；`

1\. 观察者模式

* 定义： `定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖都会收到通知并自动更新；` 
* 要点：
  + 主题是真正拥有数据的地方，观察者是主题的依赖着；
  + 让主题和观察者之间松耦合；
  + 主题唯一依赖的是观察者的对象列表；
  + 可以从观察者处推（push）, 拉（pull）数据（推的方式被认为是更正确的）；
  + 多个观察者不可以依赖特定的通知次序；
  + 每种语言中都会实现观察者模式（多种）；
  + 主题也可以叫做 “可观察者”；
  + 通过添加观察者，我们可以在任何时候扩展主题；

2\. 装饰者模式

* 定义： `动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替换方案` 
* 要点：
  + 对类进行扩展，关闭对类的修改；
  + “运行时扩展”远比“编译时期”的继承威力更大；
  + 熟悉装饰器技巧，你将能够在不改变底层任何代码的情况下，给你的对象赋予新的职责；
  + 装饰器，在比修改类的情况下，进行对类的扩展；
  + 装饰者类与被装饰组件有相同的接口/继承的实现；
* 缺点：
  + 一开始接触使用了装饰者的库，会无法轻易理解；
  + 有些代码依赖特定的类型，插入装饰者会导致类型问题；

3\. 工厂模式

* 定义： `定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类` 
* 要点：
  + 实例化这个活动不应该总是公开的进行；
  + 工厂模式，从复杂的依赖中进行解脱；
  + 使用多态让代码变的更有弹性；
  + 这样就需要等到运行时才知道抽象类的实例是哪个；
  + 变化=>影响new 实例，导致不能类型匹配；（所以，不要针对具体编程；
  + 代码中 变化 与 不变 的部分进行分离；
  + 定义一个抽象的创建者类，让子类实现这些方法；
  + 创建者类=>创建产品(抽象产品，利用多态), 产品类=>创建具体的商品类型
  + 变量不可以持有具体类型的引用；
  + 不要让类派生自具体类；
  + 不要覆盖基类中已经实现的方法；
* 缺点：

4\. 单件模式

* 定义： `确保一个类只有一个实例，并提供一个全局访问点` 
* 要点：
  + 管理自己的实例，提供全局访问以及在应用程序中担当角色这两个责任；

5\. 命令模式

* 定义：将**请求**，*（就是命令）*封装成对象，以便使用**不同的请求**，**队列**或者**日志**来参数化其他对象，命令模式也支持可撤销的操作；
* 将**发出请求的对象**和**执行请求的对象**解耦；
* 角色： 客户->命令(执行调用者的setCommand)->调用者(执行命令对象的excute)->命令(执行接收者的action)->接收者
* 客户创建一个命令对象
* 客户利用setCommand方法将命令对象存储再**调用者**中
* 客户要求**调用者**执行命令

6\. 适配器模式
7\. 外观模式
8\. 模板方法模式
9\. 迭代器模式

10. 组合模式
11. 状态模式
12. 代理模式
13. 桥接模式
14. 生成器模式
15. 职责链模式
16. 享元模式
17. 解释器模式
18. 中介者模式
19. 备忘录模式
20. 原型模式

21. 策略模式
* 定义： `定义了算法簇，分别封装起来，让他们之间可以互相替换，让算法的变化独立于使用算法的客户；` 

21. 访问者模式

22. 抽象工厂模式（制造工厂的工厂）
* 定义： `提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类` 

## 设计模式的组合(复合模式（架构模式

* 模式通常被一起使用，并被组合在同一个设计解决方案中；
* 符合模式在一个解决方案中结合两个或者多个模式，以解决一般或重复发生的问题；

## 设计的目的

* 设计的目的在于，让程序更加灵活，可维护，可扩展；（建立弹性的设计，可复用，可以维护，可以应付改变）；
* 良好的OO设计必须具备：可复用，可扩展，可维护三个特性；程序还有健壮性；
* 设计模式被认为是历经验证的OO设计经验；
* 模式不是代码, 而是针对设计问题的通用解决方案；
* 开发人员之间共享词汇；
* 代码应该对扩展开放，对修改关闭；

## 设计的注意点

* 直接实例化对象时，就是在依赖它的具体类；
* 一个类一个任务原则；
