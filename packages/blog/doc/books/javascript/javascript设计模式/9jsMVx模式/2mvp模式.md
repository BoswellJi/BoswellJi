## MVP Model-view-presenter

mvp是mvc设计模式的派生，它聚焦在改善展示逻辑上。在1990年初，它在一个叫做Taligent的公司被发明，当时他们正在为c++通用点环境开发模型。尽管mvc和mvp目的都是跨多组件的关注点分离，它们之间还是有一些基本的不同的。

对于这个总结的目的，我们将会聚焦在最适合web基础架构的mvp版本。

## Models,Views,Presenters

mvp中的p表示呈现者。它是一个包含视图的用户接口业务逻辑的组件。不像mvc,调用视图被委托给呈现者，它从视图中解耦，而是通过接口与它对话。这个对所有有用的事情友好，比如：能够在单元测试中模拟视图。

mvp最常见的实现是使用一个包含没有逻辑的标题的被动视图。如果mvc和mvp不同，那是因为c和p做不同得事情。在mvp中，p观察models并且当models改变的时候更新views。p高效的绑定models到views,这是以前由mvc中的controllers持有的责任。

通过视图请求，表现者执行任何处理用户请求的工作，并且把数据回传给视图。在这个层面，他们保留数据，维护它以及和持久化数据的服务层进行交互（模型）。模型可能会触发事件，但是模型是订阅它们的表现者的角色以至于它能更新视图。在这个被动的架构中，我们没有直接数据绑定的概念。视图暴露了表现者能够用来设置数据的设置器（setters）。

mvc中的这个改变的好处是增加了我们应用程序的可测试性以及以及给视图和模型之间提供了一个更加干净的分离。但是这个不是没有代价的，因为在这个模式中缺少数据绑定的支持通常意味着必须关照这个分离的任务。

尽管被动视图的常用实现是用来实现一个界面的视图，也有不同的版本，包括事件的用法，它可以更能够从展现者中解耦视图。因为在js中我们没有界面结构，所以这里我们使用协议比使用一个显示的界面更多。从技术上讲，它仍然是一个api，并且从这个视角来看。称它为界面可能它对我们是公平的。

还有一个mvp的超级版本控制器变种，它更接近mvc和mvvm模式，因为它提供模型直接从视图中数据绑定。`键值观察(KVO)插件(如Derick Bailey的Backbone)。倾向于从被动视图中提取Backbone，更多地进入监督控制器或MVVM变体`。

## mvp或者mvc

mvp一般最通常被用在企业级应用程序中，尽可能多的复用展现逻辑在其中是很必要的。非常复杂的视图的应用程序和大量用户交互可能发现这里mvc不太适合这个需求作为需要重度依赖多控制器的问题的解决方案。在mvp中，所有复杂逻辑都能够被封装到展现者中，它能够更好简化维护。

因为mvp视图通过界面被定义，以及技术上来说，界面只是系统和视图之间的联系人（除了展现者以外），这个模式还允许开发者编写展现逻辑，不需要等待设计者产出应用程序的布局和图形。

取决于实现，mvp或许比mvc更容易自动化单元测试。经常被引用的理由是展现者能够被用作完整的用户界面的模拟以及它能够独立于其他组件进行单元测试。在我的经验中，这个真的取决于我们实现mvp使用的语言（在js项目中选择mvp和asp.net选择mvp有很大不同。）

最终，考虑到mvc和mvp的之间的不同是语义上的，所以mvc担忧的问题，mvp可能同样会有。只要我们干净地分离关注到模型，视图和控制器（或者展现者）中，尽管我们选择变种，我们也能够获取相同的最大收益。

## mvc,mvp和backbone.js

非常少的，如果任何架构js框架宣称使用它们经典格式实现mvc或者mvp模式，许多开发人员并不认为mvc和mvp是互斥的。（事实上，在我们了解像asp.net或者gwt的web框架时，更可能了解严格实现的mvp）。这是因为它能够有额外的展现者/视图逻辑在我们的应用程序中，但是仍然认为它是一种mvc的风格。

backbone贡献者赞同这种思维方式，当她将视图分离成各自不同的组成部分时，她需要一些东西来把它们组装起来。这可以是一个控制器路由，或者一个回调来响应正在获取的数据。

那就是说，不管怎样，一些开发者感觉backbone.js更适合mvp的描述比用mvc。他们的观点是这样：

* mvp中的展现者比控制器能更好的描述Backbone.View（在视图模板与绑定它的数据之间的层）
* 模型适合Backbone.Model（它和mvc中的模型根本不同）
* 试图最能代表模板