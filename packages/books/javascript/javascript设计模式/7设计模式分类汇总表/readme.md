我早期学习设计模式的经验中，我自己发现下面的表格，它提醒许多模式必须提供什么。它包含了Gof提到的23种设计模式。原始的表格是Elyse Nielsen在2004年下半年总结的，我已经在必要的地方修改过它，来适合我们在本书这一部分的讨论。

我推荐实用这个表格作为参考，但是记着，还有许多额外的模式在这里没有提到，但是会在这本书的后面会讨论。

## 关于类的简短笔记

注意：es2015引入了原生的类支持到js中，但是，首先，它们是js现存基于原型的继承模型的语法糖。我们不会在书中涉及es2015类，但是mdn又它们极好的介绍。

记住，表格中又得模式参考了类的概念。在es5中，js是无类语言，但是类能实用函数模拟。

想要做到这个的最统一的方法是定义js函数，之后，我们在其中使用new关键字来创建对象。this能够被用来帮助定义对象的属性以及方法，如下：

```js
// A car "class"
function Car( model ) {
 
  this.model = model;
  this.color = "silver";
  this.year = "2012";
 
  this.getInfo = function () {
    return this.model + " " + this.year;
  };
 
}
```

之后，我们可以使用Car构造函数实例化对象，我们像下面这样定义：

```js
var myCar = new Car("ford");
 
myCar.year = "2010";
 
console.log( myCar.getInfo() );
```

使用js定义类的更多方式，看Stoyan Stefanov的关于它们的有用博客。

现在，让我们继续查看表格：


## 创建型    基于创建对象的概念

* 类

工厂方法    这使得基于接口数据或事件的多个派生类成为一个实例

* 对象        

抽象工厂    创建几个相似的类的实例，而不需要详细关注类

建造者      单独的对象从它的代表中构造，一直创建相同类型的对象

原型        用来拷贝或者克隆的完整的初始化实例

单例        只有单个又全局访问点的实例的类

## 构造型    基于构建对象块的思想

* 类

适配器        匹配不同类的接口，因此，尽管接口不兼容，类还是能够在一起工作

* 对象

桥接          把对象的接口和它的实现分离，这样两者可以独立变化

组合          简单组合对象的结构，使得整个对象不只是各个部分总和

装饰器        动态的给对象添加可选处理

门面          隐藏了整个子系统的复杂度的单个类

享元          一种细粒度的实例，用于有效共享包含在其他地方的信息

代理          一个代表真实对象的占位符对象

## 行为型 基于对象一起玩耍和工作的方式

* 类

解释器         在应用中，包含语言元素用来匹配目标语言的语法的一种方式

模板方法       在方法中创建算法的外壳，延迟额外的步骤到子类中

* 对象

职责链         对象链之间床底请求来找到处理请求的对象的方法    

命令           封装一个命令请求作为一个启用的对象，日志和/或请求队列，以及给未处理请求提供错误处理

迭代器          连续的访问集合对象，而不用了解集合的内部工作原理

中介者          在类之间定义简单的通信来阻止一组类相互显示引用

备忘录          捕获一个对象的内部状态，以便之后能够恢复它

观察者          通知许多类改变来确保类之间的统一的方式

状态            状态改变时，它修改对象的行为

策略            将算法封装在类中，将选择与实现分离

访问者          给类添加一个新的操作符，而不会改变类

