## 概述

这个章节描述了javascript的异常处理如何工作。从什么时异常处理的一般解释开始。

在异常处理中，你经常分组紧密耦合的语句。如果，当你正在执行那些语句的时候，它们中的一个发生了一个错误，之后，它让你无法继续执行剩余的语句。取而代之的时，你尽量优雅的从错误中修复过来。这个让人想到事物，（但是没有原子性的）。

让我们看看没有异常处理的代码：

``` javascript
function processFiles() {
    var fileNames = collectFileNames();
    var entries = extractAllEntries(fileNames);
    processEntries(entries);
}

function extractAllEntries(fileNames) {
    var allEntries = new Entries();
    fileNames.forEach(function(fileName) {
        var entry = extractOneEntry(fileName);
        allEntries.add(entry); // (1)
    });
}

function extractOneEntry(fileName) {
    var file = openFile(fileName); // (2)
    ...
}
...
```

最好的方式是响应一个错误在openFile()中，很明显地，语句1应该不会被执行的。但是我们也不想要废弃extractAllEntries()方法。取而代之的，跳过过当前文件，并且进行下一步时满足的。要做到这样，我们添加异常处理到之前的代码中：

``` javascript
function extractAllEntries(fileNames) {
    var allEntries = new Entries();
    fileNames.forEach(function(fileName) {
        try {
            var entry = extractOneEntry(fileName);
            allEntries.add(entry);
        } catch (exception) { // (2)
            errorLog.log('Error in ' + fileName, exception);
        }
    });
}

function extractOneEntry(fileName) {
    var file = openFile(fileName);
    ...
}

function openFile(fileName) {
    if (!exists(fileName)) {
        throw new Error('Could not find file ' + fileName); // (1)
    }
    ...
}
```

1. 异常处理有两个层面，如果有一个问题在他发生的地方不能被处理，抛出一个异常。
2. 找到能够处理错误的地方：捕获异常。

在(1)处，下面的结构处于活跃状态：

``` 
processFile()
        extractAllEntries(...)
            fileNames.forEach(...)
                function (fileName) { ... }
                    try { ... } catch (exception) { ... }
                        extractOneEntry(...)
                            openFile(...)
```

直到所有构造遇到活跃状态的try语句，在1处的throw语句才唤醒树和叶子。它之后调用语句的catch块，以及给他传递异常值。

