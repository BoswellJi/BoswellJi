## 概述

如果一个函数离开创建它的作用域，它还与那个作用域的变量保持连接（周围作用域），例如，变量提供给函数跨函数调用之间的保持状态。

```javascript
function createInc(startValue) {
    return function (step) {
        startValue += step;
        return startValue;
    };
}
```

通过createInc()函数返回没有丢失对startValue变量的联系，变量提供带有保持跨函数调用的状态的函数。名字来源于一个闭包关闭一个函数自由变量的事实。如果变量没有被定义在函数中，就是自由的。就是说，它来自外部。

```javascript
> var inc = createInc(5);
> inc(1)
6
> inc(2)
8
```

一个闭包是一个函数加与创建这个函数的作用域的链接。

## 通过环境来处理闭包

一个闭包是执行已经离开它的作用域环境仍然存活的例子。说明闭包如何工作，让我们检查之前与createInc()方法的交互，并且把它分成四个步骤（每个步骤期间，活动执行上下文和他的环境是高亮；如果一个函数活跃，他也会变得高亮）：

1. 这个步骤在交互之前发生，和在createInc()函数定义执行之后。createInc的入口已经被添加到全局环境，并且指向一个函数对象。

Execution contexts   Lexical environments   Functions

2. 这个步骤发生在调用createInc()函数执行期间。创建createInc的一个新鲜环境，并且推入栈中。它的外部环境是全局环境。（与createInc.[[scope]]相同）。环境保存startValue变量。


3. 这一步发生在给inc赋值之后，从createInc函数返回之后，执行上下文指向的环境会从栈中移除。但是环境仍然存在堆里。因为inc.[[scope]]引用它，inc是一个闭包（函数加出生环境）。


4. 这一步发生在inc()函数执行期间，一个新的环境被创建，并且一个执行上下文指向已经被推到栈中的环境。它的外部环境是inc的[[scope]]。外部环境指定inc访问startValue.


5. 这一步发生在inc()执行之后，不再有引用指向inc的环境（执行上下文，outer字段，或者[[scope]]）。因此它不再被需要了，并且会从堆中被移除。

## 陷阱：无意间共享环境

有时，你创建的函数的行为会被当前作用域中的一个变量影响。因为每个函数应该处理当函数被创建时的变量的值。但是由于函数是闭包，函数总是处理变量的当前值。在循环中，这可能会阻止事情正常运转。一个更清晰的案例：

```javascript
function f() {
    var result = [];
    for (var i=0; i<3; i++) {
        var func = function () {
            return i;
        };
        result.push(func);
    }
    return result;
}
console.log(f()[1]());  // 3

```

f()函数返回带有三个函数的数组。所有函数仍然能访问f的环境，所以可以访问i。事实上，它们共享相同的环境。循环完成之后，环境中的i的值为3。因此，所有的函数返回3。

这个不是我们想要的。要修复这件事，创建一个使用它的函数之前，我们需要对索引i进行一个快照。换句话说，我们想要包裹没有i值的每一个函数在函数创建的同时。因此，我们采取下面的步骤：

1. 在返回的数组中给每个函数创建一个新环境。
2. 存储在那个环境中i的当前值。

只需要函数创建环境，所以我们使用IIFE来完成第一步：

```javascript
function f() {
    var result = [];
    for (var i=0; i<3; i++) {
        (function () { // step 1: IIFE
            var pos = i; // step 2: copy
            var func = function () {
                return pos;
            };
            result.push(func);
        }());
    }
    return result;
}
console.log(f()[1]());  // 1
```

注意这个案例有真实世界的关联，因为当你通过循环给dom元素添加事件处理器时，类似的情况会出现。