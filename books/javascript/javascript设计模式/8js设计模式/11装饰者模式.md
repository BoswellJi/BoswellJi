装饰者是致力于促进代码复用的结构化设计模式，和混合模式相似，他们被认为是对象子类化的另一个可行的替代品。

传统地，装饰者提供动态地再系统现存类中添加行为的能力。思想是装饰自身对类的基本功能不是必要的。否则，它会被放入超类自身。

它们能够被用来修改现有系统，我们想要在对象中添加额外的特性而不需要严重修改使用它们的底层代码。开发者使用它们的共同理由是，它们的应用可能包含需要大量对象的不同类型。想想一下，比如说，需要定义上百个不同的对象构造器，一个js游戏。

对象构造器可能代表不同的玩家类型，每个都有不同的能力。指环王游戏可能需要构造器，Hobbit,Elf，Orc, Wizard, Mountain Giant, Stone Giant等等，但是可能轻易的有成百个。如果我们以能力作为考虑因素，想想一下，我们不得不创建子类给每个能力类型的组合，例如：HobbitWithRing等等。这非常不切合实际，而且当我们考虑不同能力的增长数量时，必定不可管理。

装饰器模式没有严重依赖如何创建对象，而是聚焦在扩展它们的功能的问题。而不是只依赖原型继承，我们与单个基础对象一起工作，并且渐近地添加装饰器对象来提供额外的功能。思想是这个而不是子类，我们添加属性或者方法给基础对象，所以它更加现代化。

用js添加新属性是非常直接的过程，所以，记住这个，一个非常简单的装饰器获取被实现，如下：

```js
// A vehicle constructor
function Vehicle( vehicleType ){
 
    // some sane defaults
    this.vehicleType = vehicleType || "car";
    this.model = "default";
    this.license = "00000-000";
 
}
 
// Test instance for a basic vehicle
var testInstance = new Vehicle( "car" );
console.log( testInstance );
 
// Outputs:
// vehicle: car, model:default, license: 00000-000
 
// Lets create a new instance of vehicle, to be decorated
var truck = new Vehicle( "truck" );
 
// New functionality we're decorating vehicle with
truck.setModel = function( modelName ){
    this.model = modelName;
};
 
truck.setColor = function( color ){
    this.color = color;
};
 
// Test the value setters and value assignment works correctly
truck.setModel( "CAT" );
truck.setColor( "blue" );
 
console.log( truck );
 
// Outputs:
// vehicle:truck, model:CAT, color: blue
 
// Demonstrate "vehicle" is still unaltered
var secondInstance = new Vehicle( "car" );
console.log( secondInstance );
 
// Outputs:
// vehicle: car, model:default, license: 00000-000
```

简单实现的类型是函数，但是它不能真正的演示所有装饰器能够提供的力量。为此，我们首先来看看我对咖啡案例的变化，它来自一本优秀的书《head first design patterns》，它是围绕购买Macbook的模型。

## 例子2：使用多个装饰器来装饰对象

```js
// The constructor to decorate
function MacBook() {
 
  this.cost = function () { return 997; };
  this.screenSize = function () { return 11.6; };
 
}
 
// Decorator 1
function memory( macbook ) {
 
  var v = macbook.cost();
  macbook.cost = function() {
    return v + 75;
  };
 
}
 
// Decorator 2
function engraving( macbook ){
 
  var v = macbook.cost();
  macbook.cost = function(){
    return v + 200;
  };
 
}
 
// Decorator 3
function insurance( macbook ){
 
  var v = macbook.cost();
  macbook.cost = function(){
     return v + 250;
  };
 
}
 
var mb = new MacBook();
memory( mb );
engraving( mb );
insurance( mb );
 
// Outputs: 1522
console.log( mb.cost() );
 
// Outputs: 11.6
console.log( mb.screenSize() );
```

在上面的例子中，我们的装饰器正在重写MacBook()基类对象的.cost()函数来返回Macbook当前价格加上被指定的更新价值。

它被认为是一种装饰，就像最初的macbook对象构造器方法，没有被覆盖以及任何其他我们定义为Macbook的一部分的属性保持不变和完整的。

没有真实的定义一个接口，上面的案例，从创始者移动到接收者时，我们移除了确保对象满足接口的责任。

## 仿古装饰器

我们现在打算查看一个首次在js的高级js设计模式中出现的装饰器变种。

不像之前的许多案例， Diaz 和 Harmes更关心装饰器如何在其他编程语言中使用接口概念实现，我们之后会定义更多细节。

注意：这个特别的装饰器变体提供了引用目标。如果发现它过度的复杂，我推荐选择之前涉及到的更简单的实现。

## 接口

高级js设计模式描述装饰器为一个模式，它被用来在相同接口的其他对象中透明的包裹对象。一个接口是定义一个对象应该有的方法的方式，但是它事实上不能直接指定，这些方法如何实现。

它们还可以指出方法需要传递的参数，但是这个可以看作可选的。

所以，为什么我们要在js中使用接口？想法是它们是自文档化以及促进可复用能力。理论上，接口也通过确保更改它们一定也让对象实现它们使得代码更稳定。

下面是一个使用鸭子类型的js的接口实现例子，一种有助于确定是否一个对象时基于它实现的方法的构造器的示例。

```js
// Create interfaces using a pre-defined Interface
// constructor that accepts an interface name and
// skeleton methods to expose.
 
// In our reminder example summary() and placeOrder()
// represent functionality the interface should
// support
var reminder = new Interface( "List", ["summary", "placeOrder"] );
 
var properties = {
  name: "Remember to buy the milk",
  date: "05/06/2016",
  actions:{
    summary: function (){
      return "Remember to buy the milk, we are almost out!";
   },
    placeOrder: function (){
      return "Ordering milk from your local grocery store";
    }
  }
};
 
// Now create a constructor implementing the above properties
// and methods
 
function Todo( config ){
 
  // State the methods we expect to be supported
  // as well as the Interface instance being checked
  // against
 
  Interface.ensureImplements( config.actions, reminder );
 
  this.name = config.name;
  this.methods = config.actions;
 
}
 
// Create a new instance of our Todo constructor
 
var todoItem = new Todo( properties );
 
// Finally test to make sure these function correctly
 
console.log( todoItem.methods.summary() );
console.log( todoItem.methods.placeOrder() );
 
// Outputs:
// Remember to buy the milk, we are almost out!
// Ordering milk from your local grocery store
```

在上面，Interface.ensureImplements为这两者提供严格的功能检查和代码而且Interface构造器能在这里找到。

使用接口的最大问题是，因为js中对它没有内置的支持，我们尝试模拟另一个语言的特性可能并不理想，这是一个危险。轻量接口能够被使用，而没有好的性能价值，而且我们将在下一节看看抽象装饰器，使用这个相同的概念。

## 抽象装饰器

为了演示装饰器这个版本的结构，我们猜想下我们有一个有一次建模的Macbook基类，并且允许我们使用许多额外的费用的增强来装饰我们的macbook的商店。

增强包括更新4GB或者8GB,雕刻，平行线或外壳，如果现在我们使用单独的子类给每个增强选项的组合建模，它可能看起来像这样：

```js
var Macbook = function(){
        //...
};
 
var  MacbookWith4GBRam = function(){},
     MacbookWith8GBRam = function(){},
     MacbookWith4GBRamAndEngraving = function(){},
     MacbookWith8GBRamAndEngraving = function(){},
     MacbookWith8GBRamAndParallels = function(){},
     MacbookWith4GBRamAndParallels = function(){},
     MacbookWith8GBRamAndParallelsAndCase = function(){},
     MacbookWith4GBRamAndParallelsAndCase = function(){},
     MacbookWith8GBRamAndParallelsAndCaseAndInsurance = function(){},
     MacbookWith4GBRamAndParallelsAndCaseAndInsurance = function(){};
```

等等。

这可能是一个不切实际的解决方案，因为一个新子类可能需要给每个可获得的增强组合。因为我们喜欢让事情保持简单，而不是维护一个巨大的子类集合，让我们看看装饰器如何更好的解决这个问题。

而不是需要我们之前看到的所有组合，我们应该能够简单的创建5个装饰器类。在这些增强类上被调用的方法传递给我们的macbook类。

在我们下个例子中，装饰器透明的包裹它们的组件并且有趣的是，它们可以互换，因为它们使用相同的接口。

这里是我们打算给macbook定义的接口：

```js
var Macbook = new Interface( "Macbook",
  ["addEngraving",
  "addParallels",
  "add4GBRam",
  "add8GBRam",
  "addCase"]);
 
// A Macbook Pro might thus be represented as follows:
var MacbookPro = function(){
    // implements Macbook
};
 
MacbookPro.prototype = {
    addEngraving: function(){
    },
    addParallels: function(){
    },
    add4GBRam: function(){
    },
    add8GBRam:function(){
    },
    addCase: function(){
    },
    getPrice: function(){
      // Base price
      return 900.00;
    }
};
```

为了让我们之后能需要添加多少就添加多少装饰器，一个抽象装饰器类使用需要实现macbook接口的默认方法来定义，剩余的选项将被子类化。

