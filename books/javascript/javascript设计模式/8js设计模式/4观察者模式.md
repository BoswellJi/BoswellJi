观察者是一个设计模式，其中一个对象维护一个依赖它的对象列表，有任何状态的改变会自动通知它们。

当主体需要通知观察者有关一些有趣的事情发生时，它广播一个通知给观察者（它能够包含特定数据相关的通知的话题）。

当我们不再想要一个特定的观察者被它们注册的主体通知变更的时候，主体能够从观察者列表中删除它们。

重新提及设计模式的公共定义通常是有用的，它是语言无关的，随着时间它的用法和优势会有更广泛的意义。观察者模式在Gof书中提供的定义：设计模式：可复用的面向对象软件设计元素，是：
`一个或者更多个观察者对主体的状态感兴趣，并且注册它们感兴趣的主体通过依附它们。当有些事物在我们观察者可能感兴趣的主体中变更，一个通知信息被发送来调用每个观察者更新的方法。当观察者不再对主体的状态感兴趣，它们可能会简单分离它们`。

我们现在可以详述我们已经学到的带有下面组件的观察者模式的实现了：

主体：
观察者：
具体的主体：
具体的观察者：

首先，让我们模拟一个主体可能有的依赖观察者的列表：

```js
function ObserverList(){
  this.observerList = [];
}
 
ObserverList.prototype.add = function( obj ){
  return this.observerList.push( obj );
};
 
ObserverList.prototype.count = function(){
  return this.observerList.length;
};
 
ObserverList.prototype.get = function( index ){
  if( index > -1 && index < this.observerList.length ){
    return this.observerList[ index ];
  }
};
 
ObserverList.prototype.indexOf = function( obj, startIndex ){
  var i = startIndex;
 
  while( i < this.observerList.length ){
    if( this.observerList[i] === obj ){
      return i;
    }
    i++;
  }
 
  return -1;
};
 
ObserverList.prototype.removeAt = function( index ){
  this.observerList.splice( index, 1 );
};
```

下一步，让我们模拟主体和添加，移除或者通知观察者列表的观察者的能力

```js
function Subject(){
  this.observers = new ObserverList();
}
 
Subject.prototype.addObserver = function( observer ){
  this.observers.add( observer );
};
 
Subject.prototype.removeObserver = function( observer ){
  this.observers.removeAt( this.observers.indexOf( observer, 0 ) );
};
 
Subject.prototype.notify = function( context ){
  var observerCount = this.observers.count();
  for(var i=0; i < observerCount; i++){
    this.observers.get(i).update( context );
  }
};
```