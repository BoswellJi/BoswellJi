在这章中，我们打算回顾三个非常重要的架构模式-mvc,mvp和mvvm。过去，这些设计模式已经重度被使用于组织桌面和服务端应用，直到最近几年，才被应用于js中。

因为许多js开发者当前使用这些模式来选择实用的库，比如用mvc类的结构实现的Backbone.js，我们会比较现代解决方案如何，比如，与传统模式相比，它们对于mvc的解释有什么不同。

## MVC Model-view-controller

mvc鼓励通过关注点分离来改善应用程序组织的架构模式。它强迫从用户接口中（view）隔离业务数据（models）,以及一个传统的第三方组件（controllers）来管理逻辑和用户输入。此模式起初被TR设计，在他工作在smalltalk-80期间，它在那里起初被叫做Model-view-controller-Editor。在1995年的软件模式：可复用的面向对象软件元素中被深入描述，这对推广它的使用起到了作用。

## js开发者的mvc

我们已经回顾了70年代，但是让我们回到这里和当前。在现代，mvc模式已经被应用与不同的编程语言范畴，包括我们最熟知的：js。js现在有大量拥有mcv支持的框架（或者它的变种，我们成它为mv*家族），允许开发者轻松的添加结构到它的应用程序中，而不会有大影响。一个因为缺乏结构，非常难读，难维护的描述代码的术语。

这些框架包括，像Backbone,Ember.js和angularjs。指出避免意大利面条代码的价值。现代js开发者理解这个模式提供了什么是重要的。这个允许我们高效的领会，这些框架能够使我们做到什么不同的。

我们直到mvc由三个核心组件组成：

## 模型

模型管理一个应用程序的数据。它们既不关注用户接口也不关注呈现层，反而代表应用程序可能需要的唯一的数据格式。当模型改变的时候，它将会代表性的通知它的观察者（例如：views,我们之后会涉及的概念），以至于发生改变它们可以进行相应的反应。

为了进一步理解models，让我们想想一下，我们有一个js图片画廊应用程序。在图片画廊中，图片的概念值得有自己的模型，因为它代表唯一的特定领域数据的类型。比如一个模型可能包含相关的属性，比如标题，图片地址，以及额外的元数据。一个特定的图片会被存储在一个模型实例中以及模型还可以重用。下面我们能够看到一个使用backbone实现的非常简单的模型的案例。

```js
var Photo = Backbone.Model.extend({
    // Default attributes for the photo
    defaults: {
      src: "placeholder.jpg",
      caption: "A default image",
      viewed: false
    },
 
    // Ensure that each photo created has an `src`.
    initialize: function() {
       this.set( { "src": this.defaults.src} );
    }
});
```

模型内置的能力因框架而异，但是对于它们支持属性验证却相当统一的，其中的属性代表模型属性，比如模型的标识符。当我们在真实世界的应用程序中使用模型时，我们一般还希望模型持久化。持久化允许我们编辑和更新模型，了解模型的最新状态将保存在内存中，用户的本地存储数据存储中或与数据库同步。

另外，一个模型还可能被多个视图观察。如果说，我们的图片模型包含像它的位置（经度和纬度），在图片中出现的朋友以及标签列表等数据，一个开发者可能决定提供一个单一的视图来展示这三个方面的每个。

现代化MVC/MV*框架所提供的模型分组的方法这并不少见（例如：在backbone中，这些组被称为集合）。通过分组管理模型，我们可以根据来自组的通知编写应用程序逻辑，如果组中包含的任何模型发生了更改。这个避免了需要手动观察独立的模型实例。

一个模型分组进到简化的backbone集合的案例展示在下面。

```js
var PhotoGallery = Backbone.Collection.extend({
 
    // Reference to this collection's model.
    model: Photo,
 
    // Filter down the list of all photos
    // that have been viewed
    viewed: function() {
        return this.filter(function( photo ){
           return photo.get( "viewed" );
        });
    },
 
    // Filter down the list to only photos that
    // have not yet been viewed
    unviewed: function() {
      return this.without.apply( this, this.viewed() );
    }
});
```

关于mvc更老的文本可能还包含称为模型关系应用程序的概念`state`。在js应用程序中state有不同的含义，一般称为当前state,例如，在固定点上的用户屏幕的视图或者子视图（带有特定数据）。state是一个当你在了解单页应用程序时候才会正规讨论的话题，其中state的概念需要被模拟。


所以总的来说，models主要于业务数据有关。

## views 

views是一个可见的模型呈现，它呈现一个被过滤的它们当前状态的view。尽管smallTalk视图是关于绘制和维护位图，js视图是关于构建和维护dom元素。

一个视图一般监听一个模型并且当模型改变时被通知，允许视图进行相应的更新。设计模式文化一般称视图为哑，因为它们对于应用程序中的模型和控制器的了解很有限。

用户能够和视图交互，并且这个包括读取和编辑模型的能力。因为视图是呈现层，我们一般以用户友好的方式呈现编辑和更新的能力。例如，在我们更早讨论的图片走廊应用程序的样板中，模板编辑能够通过编辑视图来简化，在视图中，选择特定图片的用户能够编辑它的元数据。

更新模型的真实任务开始在控制器中。（我们之后将会涉及到。

让我们使用一个原生的js简单模板来进一步探索视图。下面我们能够看到一个创建了单个图片视图的函数。同时使用一个model实例和一个controller实例。

我们定义了一个实用的render()在我们视图中，它的责任是使用js模板引擎来渲染photoModel的内容，以及更新我们视图的内容。

## controllers

控制器是models和view之间的中间人，它经典的责任是在用户操作views时，用来更新model。

## mvc给了我们什么？

在mvc中关注点分离促进一个应用程序功能和启用的简单模块化。

1. 更容易整体维护。


## MVP Model-view-presenter

mvp是mvc设计模式的派生，它聚焦在改善表示逻辑上。在1990年初，它在一个叫做Taligent的公司被发明，当时他们正在为c++通用点环境开发模型。尽管mvc和mvp目的都是跨多组件的关注点分离，它们之间还是有一些基本的不同的。

对于这个总结的目的，我们将会聚焦在最适合web基础架构的mvp版本。

## Models,Views,Presenters

mvp中的p表示呈现者。它是一个包含视图的用户接口业务逻辑的组件。不像mvc,调用视图被委托给呈现者，它从视图中解耦，而是通过接口与它对话。这个对所有有用的事情友好，比如：能够在单元测试中模拟视图。

最通用的mvp实现是使用一个被动的视图，包含没有逻辑的标题。如果mvc和mvp不同，那是因为c和p做不同得事情。在mvp中，p观察models并且当models改变的时候更新views。p高效的绑定models到views,这是以前由mvc中的controllers持有的责任。

## mvp或者mvc

## MVVM

mvvm是一个基于mvc和mvp的架构模式，它想要更清晰的划分业务逻辑中的用户接口开发和应用程序中的行为。为了这个目的，这个模式的许多实现使得定义数据绑定的用途允许视图上的工作从其他层分离。

这个促使UI和开发工作几乎同时在相同的代码基础中发生。ui开发在它们的文档标签中编写vm的绑定，其中的model和vm由工作在应用程序逻辑的开发者来维护。