## 概述

* 树的节点：

``` 
function node(data,left,right){
  this.data = data;
  this.left = left;
  this.right = right;
}

```

## 树结构

* 定义:

* 优势:
  + 增，删，查 非常快

* 劣势: 

* 树的三个概念
  + 高度 （从下往上，从0开始）
  + 深度 （从上往下，从0开始）
  + 层级 （从上往下，从1开始）

* 分类:
  + 无序树
  + 有序树
  + 二叉查找树
    - `任意一个节点， 其左子树中的每个节点的值， 都要小于这个节点的值， 而右子树节点的值都大于这个节点的值` ，这种二叉树就叫作满二叉查找树。

  + 完全二叉树
    - `叶子节点都在最底下两层， 最后一层的叶子节点都靠左排列， 并且除了最后一层， 其他层的节点个数都要达到最大` ，这种二叉树叫作完全二叉树。

  + 满二叉树
    - `叶子节点全都在最底层， 除了叶子节点之外， 每个节点都有左右两个子节点` ，这种二叉树就叫作满二叉树。

* 存储方式:
  + 链式存储法（链表）

  + 顺序存储法 (数组）
    - 我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。
    - 优势：节省内存（ `这是为什么二叉树要求最后一层子节点都靠左的原因，不会有空子节点` ， `只浪费了下标为0的存储位置` ），通过下标的方式将整棵树串联起来
    - *堆其实就是完全二叉树，一般使用数组存储*

* 树的遍历:
  + 前序遍历：任意节点，先打印这个节点，再打印左子节点，最后打印右子节点
  + 中序遍历：任意节点，先打印左子节点，再打印本身节点，最后打印右子节点
  + 后序遍历：任意节点，先打印左子节点，再打印右子节点，最后打印本身节点

* 节点的分类:
  + 根节点：没有父节点的节点
  + 叶子节点：没有子节点的节点
