## 概述

* 完全实现 `封装` , `继承` , `多态` ，称为面向对象语言，满足其中部分特性的语言称为 `基于对象语言` ；

* 对象系统的继承特性：
  + 基于类
  + 基于原型
  + 基于元类

* js中，没有使用类，而是使用 `构造器` 机制来实现 `类` 的某些功能；

## 空对象null, 空的对象

* null因为是对象类型可以用for ... in 进行遍历；，只不过为空而已；
* null不是Object实例，所以instanceof会返回false; 

## 原型继承的基本性质

* 动态绑定于静态绑定；
* 原型也是对象的实例，是一个最关键的性质；
* `构造器实例` ，都是 `复制` 自构造器的 `原型对象` ；

## 空的对象是所有对象的基础

## 构造复制？写时复制？读遍历？

* 构造复制：导致每个实例都占用相同的内存，导致内存占用急速增加；
* 写时复制：指明 `实例` 等于 `原型实例` ，在读取时候，顺着指示去读取原型；
* js使用的是读遍历；

## 构造过程： 从函数到构造器

* 对像的构造过程；（函数作为构造器做了什么？
  + 不会在声明一个函数时，创建一个对象，并使prototype指向它；
  + prototype在函数初始化时，无值，可以看作为null；
  + 只有在使用prototype时，才创建 `原型对象实例` ；
    - 原型对象总是Object构造器的实例；
  + 使用`new`运算符创建构造器实例时，引擎会再造一个原型对象实例；

* 函数与构造器的区别？
  + prototype是否是一个有意义的值；

## 预定义属性和方法

* 对象实例： ^proto = Object.prototype ^props = properties table

## 原型链的维护

* 两个原型链
  + 构造器有一个prototype的成员，实例有一个指向原型的属性，称为 `内部原型链` ；
  + 以便和构造器的prototype组成 `构造器原型链` ；

* constructor属性的维护
  + 由于原型继承时，会修改当前构造器prototype的constructor属性，所以，导致实例的constructor属性错误；

* 内部原型链的作用
  + 用户修改constructor，不用担心，实例与父类的一致性；

## 原型继承的实质

* 原型修改
  + 子类在获取成员列表时，必将回溯到改类；

* 原型继承

* 从无到有

* 如何理解 `继承来的成员`
