## 动态特性

* 解释而非编译

* 可以重写标识符

* 动态类型系统

* 动态执行

* 丰富的数据外部表示

## 动态执行系统分为两个阶段:

* 动态装载

* 动态执行(eval)
  + 主要是由eval带来的效果

*某些系统可能会将两个操作合二为一, 装载之后, 直接动态执行*

### 动态执行与闭包

* js的代码总是运行在闭包中, 会有一个scriptobject, 用来访问当前闭包中的变量表, 与内嵌函数表, 通过parent属性访问到外层闭包; 

* 系统全局闭包, 当前函数闭包, eval的代码准备哪个闭包; 

* eval是js的全局对象global提供的方法, 如果要访问global对象, 可以通过宿主对象, 浏览器环境中是window; 

* eval的闭包, 在moz中是全局闭包, 在ie位函数闭包; 源于对eval使用的闭包环境的理解并不相同; 

### eval使用全局闭包

* spiderMonkey中使用eval执行代码改变的是函数闭包
  + window.eval改变的是全局闭包; 

* 允许eval使用全局闭包并不是好主意, 不应当让eval对函数外产生副作用; 
  + 在jsscript中window.execScript方法中执行的代码总是在全局闭包中执行; 

### eval使用当前函数的闭包

* eval代码中允许声明局部变量, 那就必须保证语法树能在eval过程中动态维护; 

* js代码解释执行的过程:
  + js代码文本解释为语法树, 然后按照语法树来执行; 
  + 将语法树中与该函数有关的 `形式参数` , `函数局部变量` , `upvalue` , `内层的嵌套` 等信息, 复制到一个结构中, *scriptObject*
  + 执行函数体中的代码, 需要访问变量时, 先考察 `scriptObject` 中的局部变量, 最后考察 `upvalue`

### 动态执行过程中的语句, 表达式和值

* eval是一个动态的语句执行系统, 不是动态的取值/赋值系统

* eval将 `{name:'js'}` 中的一对大括号视为一个复合语句的标识, 但是对于 `{name:'jmz',age:12}` 中的age后的 `:` 不能很好的解析; 
  + 解决这个问题的方式就是 `eval('({name:"js"})')`

### 奇特的, 甚至是负面的影响

* 导致变量作用域发生变化; 

* js代码不可编译的性质, 也是由动态执行导致的; 支持动态执行的代码, 是不能真实编译的; 
  + 真实编译指的是编译为二进制的 `机器代码` ; 
  + 不是某种支持动态执行的 `虚拟机环境` 中的中间代码; 
